<html><head><meta charSet="utf-8"/><title>CLJS 01 Now witness the expressive power of Slate with ClojureScript - Slate with ClojureScript</title><link rel="stylesheet" href="css/style.css?v=1442DB7F9CDBA4514F86CE9C81CF65441E58DE98"/></head><body><span id="forkongithub"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs">Fork me on GitHub</a></span><a href="https://jeremyrsellars.github.io/slate-cljs-walkthroughs/"><h1 class="title">Slate with ClojureScript</h1></a><div id="app"><div><h1>CLJS 01 Now witness the expressive power of Slate with ClojureScript</h1><div class="objective">Make Ctrl+b rotate through some different emphasis formats.  See what features of ClojureScript work well with and slate development.</div><h3>Interactive Demo</h3><p class="description">Select some text and try the buttons, Ctrl+b (to cycle through the emphasis modes), ctrl-` as before.</p><div id="editor-parent"><div><button>Bold</button><button>Code Block</button></div><div data-gramm="false" role="textbox" data-slate-editor="true" data-slate-node="value" contenteditable="true" style="outline:none;white-space:pre-wrap;word-wrap:break-word"><p data-slate-node="element"><span data-slate-node="text"><span data-slate-leaf="true" style="font-weight:normal;font-style:normal;color:unset"><span data-slate-string="true">A line of text with some </span></span></span><span data-slate-node="text"><span data-slate-leaf="true" style="font-weight:normal;font-style:normal;color:red"><span data-slate-string="true">emphasized text</span></span></span><span data-slate-node="text"><span data-slate-leaf="true" style="font-weight:normal;font-style:normal;color:unset"><span data-slate-string="true">.  You can select the text and use Ctrl+b to cycle through the emphasis modes.</span></span></span></p></div></div><div id="source"><div><div><h1></h1><div id="source"><div><div><h1></h1><div id="source"><div><h2>How does CLJS Destructuring work with slate node objects?</h2>Slate nodes are #js {} objects. I was a bit surprised to find that there isn&#x27;t really an efficient, succinct way to parse the Slate Node properties into clojure bindings. It can be succinct with <code>js-&gt;clj</code> and then destructuring the resultant Clojure map, but it&#x27;s not terribly fast. For my purposes, it&#x27;s better to be clear than clever. I haven&#x27;t found a compelling reason to trade idiomatic slate for idiomatic ClojureScript. <p></p>Another thing to remember is Clojure types don&#x27;t serialize very well to the slate default of JSON.</div><h3>ClojureScript</h3><pre><code class="language-clojure">(defn demo-destructuring-options   &quot;Which methods of comprehending a Slate node actually work?    See some ideas that work or don&#x27;t work below&quot;   []   (let [leaf #js {:text &quot;&quot;, :bold? false}          ; Me: &quot;ClojureScript has this cool destructuring syntax....&quot;         ; Nope! Sorry, we *cannot* destructure #js objects like this         ; because {:strs [...]} destructuring is for Clojure maps.         #_#_         {:strs [text bold?], :or {bold? false}} leaf   ; &lt;- won&#x27;t work          ; Me: &quot;That&#x27;s ok.  It also has the short and sweet .-property syntax&quot;         ; Probably not ok! Sorry, this will probably get you into trouble         ; with advanced Closure optimizations (if you choose that path).         ; Unfortunately, it would probably work ok in dev,          ; and worse, might even *partially* work in :advanced for properties         ; defined in the slate interfaces like .-text, but will almost certainly fail         ; for new properties like .-bold?         #_#_         bold? (boolean (.-bold? leaf))   ; &lt;- won&#x27;t work in :advanced          ; Me: &quot;Fine, I&#x27;ll create my own type that implements the slate Text interface         ;      and use that everywhere so I can say (.-bold? x) and use destructuring.&quot;         ; Nope!  Slate doesn&#x27;t let you use a type like this         ; even though it implements the right interface (e.g. Text, Element, Node)         ; because slate checks isPlainObject which makes sure the object         ; was created with js/Object&#x27;s constructor...          ; but ClojureScript records have their own constructor so that won&#x27;t work.         #_ (defrecord LeafText [^String text, ^boolean bold?])          ; Do this instead:         bold? (gobj/get leaf &quot;bold?&quot; false) ; supply the default value of not-bold         text  (gobj/get leaf &quot;text&quot;)                  ; Or, put the idiomatic ClojureScript attributes slightly deeper:         emphasis-leaf  #js {:text &quot;&quot;, :emphasis {:bold? true}}   ; &lt;- emphasis is a Clojure map         {:keys [bold?] :or {bold? false}} (gobj/get emphasis-leaf &quot;emphasis&quot;)         ; but, if you intend to use Transforms.setNodes, you won&#x27;t want to mix         ; attributes that you&#x27;ll want to set individually because Transforms.setNodes         ; is more like assoc than update.         ; Also, remember to take extra care around serializing the extra attributes.                  text  (gobj/get emphasis-leaf &quot;text&quot;)]              {:text text, :bold? bold?})) </code></pre></div></div><div><h1></h1><div id="source"><div><h2>How does CLJS Destructuring work with slate .nodes search results (ES6 iterators)?</h2>Slate uses ES6 iterators, and ClojureScript can turn them into destructurable sequences with <code>es6-iterator-seq</code>.</div><h3>ClojureScript</h3><pre><code class="language-clojure">(defn extract-emphasis-mode   &quot;Find the emphasis value for the first leaf.&quot;   [editor]   (let [[[text-node]]     ; &lt;-- seq destructuring         (es6-iterator-seq           (.nodes Editor editor                     #js {:match (fn [n] (and (.isText Text n)                                              (gobj/get n &quot;emphasis&quot;)                                              true))                          :universal true}))]     (gobj/get text-node &quot;emphasis&quot;))) </code></pre></div></div><div><h1></h1><div id="source"><h3>ClojureScript</h3><pre><code class="language-clojure">(defn rotate-bold-mark   [editor]   (let [em-mode (extract-emphasis-mode editor)]     (.setNodes Transforms       editor       #js { :emphasis (next-emphasis-mode em-mode)}       #js { :match #(Text.isText %)             :split true}))) </code></pre></div></div><h2>App</h2></div></div></div></div><h3>ClojureScript</h3><pre><code class="language-clojure">(defn App   []   (let [editor (useMemo #(withReact (createEditor))                         #js [])         [value setValue]         (useState          #js [#js {:type &quot;paragraph&quot;                    :children                    #js [#js {:text &quot;A line of text with some &quot;}                         #js {:text &quot;emphasized text&quot; :emphasis (next-emphasis-mode (next-emphasis-mode (next-emphasis-mode nil)))}                         #js {:text &quot;.  You can select the text and use Ctrl+b to cycle through the emphasis modes.&quot;}]}])         renderElement          (useCallback            (fn renderElement [props]              (case (.-type (.-element props))                (createElement CodeElement props)                       (createElement DefaultElement props)))            #js [])         renderLeaf          (useCallback            (fn renderLeaf [props]              (createElement Leaf props))            #js [])]     ; Add a toolbar with buttons that call the same methods.     (createElement Slate       #js {:editor editor            :value value            :onChange #(setValue %)}       (createElement &quot;div&quot; #js {}         (createElement &quot;button&quot;           #js {:onMouseDown                 (fn [event]                   (.preventDefault event)                   (rotate-bold-mark editor))}           &quot;Bold&quot;)         (createElement &quot;button&quot;           #js {:onMouseDown                 (fn [event]                   (.preventDefault event)                   (toggle-code-block editor))}           &quot;Code Block&quot;))       (createElement Editable         #js{:renderElement renderElement             :renderLeaf renderLeaf             :onKeyDown             (fn onKeyDown [event]              (when (.-ctrlKey event)               (case (.-key event)                  &quot;`&quot;                (do                 (.preventDefault event)                 (toggle-code-block editor))                 &quot;b&quot;                (do                 (.preventDefault event)                 (rotate-bold-mark editor))                                ;default                nil)))})))) </code></pre></div><h3>Where to next?</h3><ul id="nav"><li class="source-link"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs/blob/master/src/slatecljs/slate_cljs_01_now_witness_the_power.cljs#L12" class="source-link">slatecljs.slate-cljs-01-now-witness-the-power</a></li><li class="source-link"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs/blob/master/src/slatecljs/slate_cljs_01_now_witness_the_power.cljs#L98" class="source-link">CustomEditor</a></li><li class="source-link"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs/blob/master/src/slatecljs/slate_cljs_01_now_witness_the_power.cljs#L208" class="source-link">&lt;App&gt;</a></li><li class="previous"><a href="w06.html" class="previous">06 Saving to a database</a></li></ul></div></div><script>window.location.hash = "c01";</script><script src="cljs-out/dev-main.js?v=3F591B1635801B59FF09856D8CAFB2710C7CCE01"></script><link rel="stylesheet" href="highlightjs/styles/obsidian.css?v=6ED475813FE4886A58B236297862FF2F181E66F7"/><script>slatecljs.common.highlight_source("force");</script><div id="thanks-footer">Thanks for visiting.  You might also like this <a href="https://jeremyrsellars.github.io/no-new-legacy/posts/2018-09-07-generative-testing-introduction/">series about generative testing in Clojure</a> also by <a href="https://jeremyrsellars.github.io/">Jeremy Sellars</a>.</div></body></html>
