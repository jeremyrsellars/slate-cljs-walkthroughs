<html><head><meta charSet="utf-8"/><title>03 Defining custom elements - Slate with ClojureScript</title><link rel="stylesheet" href="css/style.css?v=06B7838ADC585E3A45C5022C67BD6B81DE34D3B4"/></head><body><h1 class="title">Slate with ClojureScript</h1><div id="app"><div><h1>03 Defining custom elements</h1><div class="objective">Use an event handler to set a text block to a custom element, and then back again.<span><br/>  Follow along with <a href="https://docs.slatejs.org/walkthroughs/03-defining-custom-elements" class="slate-tutorial" target="tutorial">Slate tutorial 03 Defining custom elements</a> (JavaScript).</span></div><h3>Interactive Demo</h3><p class="description">Press Ctrl+` to toggle code section for the line you&#x27;re editing.</p><div id="editor-parent"><div data-gramm="false" role="textbox" data-slate-editor="true" data-slate-node="value" contenteditable="true" style="outline:none;white-space:pre-wrap;word-wrap:break-word"><p data-slate-node="element"><span data-slate-node="text"><span data-slate-leaf="true"><span data-slate-string="true">A line of text in a paragraph.</span></span></span></p></div></div><div id="source"><div><div><h1></h1><div id="source"><div><div><h1></h1><div id="source"><div><h2>CodeElement</h2>Elements are usually block-style, in that they represent a whole line and are always containers.  Let&#x27;s define a code block node and a default node to give them different styling.</div><h3>ClojureScript</h3><pre><code class="language-clojure">(defn CodeElement   [props]   (createElement &quot;pre&quot; (.-attributes props)     (createElement &quot;code&quot; #js{}       (.-children props)))) </code></pre><h3>JavaScript (from Slate Tutorial)</h3><pre><code class="language-javascript">  //From slatecljs.slate-03-defining-custom-elements/CodeElement ([props])   // Define a React component renderer for our code blocks. const CodeElement = props =&gt; {   return (     &lt;pre {...props.attributes}&gt;       &lt;code&gt;{props.children}&lt;/code&gt;     &lt;/pre&gt;   ) } </code></pre></div></div><div><h1></h1><div id="source"><h2>DefaultElement</h2><h3>ClojureScript</h3><pre><code class="language-clojure">(defn DefaultElement   [props]   (createElement &quot;p&quot; (.-attributes props)     (.-children props))) </code></pre><h3>JavaScript (from Slate Tutorial)</h3><pre><code class="language-javascript">  //From slatecljs.slate-03-defining-custom-elements/DefaultElement ([props])   const DefaultElement = props =&gt; {   return &lt;p {...props.attributes}&gt;{props.children}&lt;/p&gt; } </code></pre></div></div><h2>App</h2>Now pull it all together.</div></div></div></div><h3>ClojureScript</h3><pre><code class="language-clojure">(defn App   []   (let [editor (useMemo #(withReact (createEditor))                         #js [])         ; Add the initial value when setting up our state.         [value setValue]         (useState          #js [#js {:type &quot;paragraph&quot;                    :children                    #js [#js {:text &quot;A line of text in a paragraph.&quot;}]}])         renderElement          (useCallback            (fn renderElement [props]              (case (.-type (.-element props))                &quot;code&quot; (createElement CodeElement props)                       (createElement DefaultElement props)))            #js [])]          (createElement Slate       #js {:editor editor            :value value            :onChange #(setValue %)}       (createElement Editable         #js{:renderElement renderElement             :onKeyDown             (fn onKeyDown [event]               (when (and (= (.-key event) &quot;`&quot;) (.-ctrlKey event))                 (.preventDefault event)                 ; Determine whether any of the currently selected blocks are code blocks.                 (let [[match]                        (es6-iterator-seq                         (.nodes Editor editor                                   #js {:match                                        (fn [n]                                           (= (.-type n) &quot;code&quot;))}))]                    ; Toggle the block type depending on whether there&#x27;s already a match.                   (.setNodes Transforms                     editor                     #js { :type (if match &quot;paragraph&quot; &quot;code&quot;)}                     #js { :match (fn [n] (Editor.isBlock editor n))}))))})))) </code></pre><h3>JavaScript (from Slate Tutorial)</h3><pre><code class="language-javascript">  //From slatecljs.slate-03-defining-custom-elements/App ([])   const App = () =&gt; {   const editor = useMemo(() =&gt; withReact(createEditor()), [])   const [value, setValue] = useState([     {       type: &#x27;paragraph&#x27;,       children: [{ text: &#x27;A line of text in a paragraph.&#x27; }],     },   ])    const renderElement = useCallback(props =&gt; {     switch (props.element.type) {       case &#x27;code&#x27;:         return &lt;CodeElement {...props} /&gt;       default:         return &lt;DefaultElement {...props} /&gt;     }   }, [])    return (     &lt;Slate editor={editor} value={value} onChange={value =&gt; setValue(value)}&gt;       &lt;Editable         renderElement={renderElement}         onKeyDown={event =&gt; {           if (event.key === &#x27;`&#x27; &amp;&amp; event.ctrlKey) {             event.preventDefault()             // Determine whether any of the currently selected blocks are code blocks.             const [match] = Editor.nodes(editor, {               match: n =&gt; n.type === &#x27;code&#x27;,             })             // Toggle the block type depending on whether there&#x27;s already a match.             Transforms.setNodes(               editor,               { type: match ? &#x27;paragraph&#x27; : &#x27;code&#x27; },               { match: n =&gt; Editor.isBlock(editor, n) }             )           }         }}       /&gt;     &lt;/Slate&gt;   ) } </code></pre></div><h3>Where to next?</h3><ul id="nav"><li class="next"><a href="w04.html" class="next">04 Applying custom formatting</a></li><li class="slate-tutorial"><a href="https://docs.slatejs.org/walkthroughs/03-defining-custom-elements" class="slate-tutorial" target="tutorial">03 Defining custom elements</a></li><li class="source-link"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs/blob/master/src/slatecljs/slate_03_defining_custom_elements.cljs#L11" class="source-link">slatecljs.slate-03-defining-custom-elements</a></li><li class="source-link"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs/blob/master/src/slatecljs/slate_03_defining_custom_elements.cljs#L66" class="source-link">&lt;App&gt;</a></li><li class="previous"><a href="w02.html" class="previous">02 Event handlers</a></li></ul></div></div><script>window.location.hash = "w03";</script><script src="cljs-out/dev-main.js?v=CF22D79FE6E78E32CD67E210609E461373A9F858"></script><link rel="stylesheet" href="highlightjs/styles/obsidian.css?v=6ED475813FE4886A58B236297862FF2F181E66F7"/><script>slatecljs.common.highlight_source("force");</script><div>You might also like this <a href="https://jeremyrsellars.github.io/no-new-legacy/posts/2018-09-07-generative-testing-introduction/">blog about generative testing in Clojure</a> also by <a href="https://jeremyrsellars.github.io/">Jeremy Sellars</a>.</div></body></html>
