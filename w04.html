<html><head><meta charSet="utf-8"/><title>04 Applying custom formatting - Slate with ClojureScript</title><link rel="stylesheet" href="css/style.css?v=06B7838ADC585E3A45C5022C67BD6B81DE34D3B4"/></head><body><h1 class="title">Slate with ClojureScript</h1><div id="app"><div><h1>04 Applying custom formatting</h1><div class="objective">Use an event handler to format a span of text span using a custom leaf node.  Toggling back again is an excercise for the reader, but you can check out Walkthrough #3 for ideas, or just move on to the next step.<span><br/>  Follow along with <a href="https://docs.slatejs.org/walkthroughs/04-applying-custom-formatting" class="slate-tutorial" target="tutorial">Slate tutorial 04 Applying custom formatting</a> (JavaScript).</span></div><h3>Interactive Demo</h3><p class="description">Press Ctrl+b to set selected text as bold.</p><div id="editor-parent"><div data-gramm="false" role="textbox" data-slate-editor="true" data-slate-node="value" contenteditable="true" style="outline:none;white-space:pre-wrap;word-wrap:break-word"><p data-slate-node="element"><span data-slate-node="text"><span data-slate-leaf="true" style="font-weight:normal"><span data-slate-string="true">A line of text in a paragraph.</span></span></span></p></div></div><div id="source"><div><div><h1></h1><div id="source"><div><div><h1></h1><div id="source"><div><h2>Leaf</h2>Leaves are usually inline-style, in that they represent something like text that flows.  Let&#x27;s define a leaf node that can be bold or not.</div><h3>ClojureScript</h3><pre><code class="language-clojure">(defn Leaf   [props]   (let [leaf (gobj/get props &quot;leaf&quot;)         bold (gobj/get leaf &quot;bold&quot;)]     (createElement &quot;span&quot;       (doto (gobj/clone (.-attributes props))         (gobj/set &quot;style&quot; #js {:fontWeight (if bold &quot;bold&quot; &quot;normal&quot;)}))       (.-children props)))) </code></pre><h3>JavaScript (from Slate Tutorial)</h3><pre><code class="language-javascript">  //From slatecljs.slate-04-applying-custom-formatting/Leaf ([props])   const Leaf = props =&gt; {   return (     &lt;span       {...props.attributes}       style={{ fontWeight: props.leaf.bold ? &#x27;bold&#x27; : &#x27;normal&#x27; }}     &gt;       {props.children}     &lt;/span&gt;   ) } </code></pre></div></div><h2>App</h2>Now pull it all together.</div></div></div></div><h3>ClojureScript</h3><pre><code class="language-clojure">(defn App   []   (let [editor (useMemo #(withReact (createEditor))                         #js [])         [value setValue]         (useState          #js [#js {:type &quot;paragraph&quot;                    :children                    #js [#js {:text &quot;A line of text in a paragraph.&quot;}]}])         renderElement          (useCallback            (fn renderElement [props]              (case (.-type (.-element props))                &quot;code&quot; (createElement CodeElement props)                       (createElement DefaultElement props)))            #js [])         ; Define a leaf rendering function that is memoized with `useCallback`.         renderLeaf          (useCallback            (fn renderLeaf [props]              (createElement Leaf props))            #js [])]          (createElement Slate       #js {:editor editor            :value value            :onChange #(setValue %)}       (createElement Editable         #js{:renderElement renderElement             ; Pass in the `renderLeaf` function.             :renderLeaf renderLeaf             :onKeyDown             (fn onKeyDown [event]              (when (.-ctrlKey event)               (case (.-key event)                  &quot;`&quot;                (do                 (.preventDefault event)                 (let [[match]                        (es6-iterator-seq                         (.nodes Editor editor                                   #js {:match                                        (fn [n]                                           (= (.-type n) &quot;code&quot;))}))]                    ; Toggle the block type depending on whether there&#x27;s already a match.                   (.setNodes Transforms                     editor                     #js { :type (if match &quot;paragraph&quot; &quot;code&quot;)}                     #js { :match (fn [n] (Editor.isBlock editor n))})))                 &quot;b&quot;                (do                 (.preventDefault event)                 (.setNodes Transforms                   editor                   #js { :bold true}                   #js { :match (fn [n] (Text.isText n))                         :split true}))                                ;default                nil)))})))) </code></pre><h3>JavaScript (from Slate Tutorial)</h3><pre><code class="language-javascript">  //From slatecljs.slate-04-applying-custom-formatting/App ([])   const App = () =&gt; {   const editor = useMemo(() =&gt; withReact(createEditor()), [])   const [value, setValue] = useState([     {       type: &#x27;paragraph&#x27;,       children: [{ text: &#x27;A line of text in a paragraph.&#x27; }],     },   ])    const renderElement = useCallback(props =&gt; {     switch (props.element.type) {       case &#x27;code&#x27;:         return &lt;CodeElement {...props} /&gt;       default:         return &lt;DefaultElement {...props} /&gt;     }   }, [])    // Define a leaf rendering function that is memoized with `useCallback`.   const renderLeaf = useCallback(props =&gt; {     return &lt;Leaf {...props} /&gt;   }, [])    return (     &lt;Slate editor={editor} value={value} onChange={value =&gt; setValue(value)}&gt;       &lt;Editable         renderElement={renderElement}         // Pass in the `renderLeaf` function.         renderLeaf={renderLeaf}         onKeyDown={event =&gt; {           if (!event.ctrlKey) {             return           }            switch (event.key) {             case &#x27;`&#x27;: {               event.preventDefault()               const [match] = Editor.nodes(editor, {                 match: n =&gt; n.type === &#x27;code&#x27;,               })               Transforms.setNodes(                 editor,                 { type: match ? null : &#x27;code&#x27; },                 { match: n =&gt; Editor.isBlock(editor, n) }               )               break             }              case &#x27;b&#x27;: {               event.preventDefault()               Transforms.setNodes(                 editor,                 { bold: true },                 { match: n =&gt; Text.isText(n), split: true }               )               break             }           }         }}       /&gt;     &lt;/Slate&gt;   ) }  </code></pre></div><h3>Where to next?</h3><ul id="nav"><li class="next"><a href="w05.html" class="next">05 Custom commands</a></li><li class="slate-tutorial"><a href="https://docs.slatejs.org/walkthroughs/04-applying-custom-formatting" class="slate-tutorial" target="tutorial">04 Applying custom formatting</a></li><li class="source-link"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs/blob/master/src/slatecljs/slate_04_applying_custom_formatting.cljs#L12" class="source-link">slatecljs.slate-04-applying-custom-formatting</a></li><li class="source-link"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs/blob/master/src/slatecljs/slate_04_applying_custom_formatting.cljs#L77" class="source-link">&lt;App&gt;</a></li><li class="source-link"><a href="https://github.com/jeremyrsellars/slate-cljs-walkthroughs/blob/master/src/slatecljs/slate_04_applying_custom_formatting.cljs#L36" class="source-link">&lt;Leaf&gt;</a></li><li class="previous"><a href="w03.html" class="previous">03 Defining custom elements</a></li></ul></div></div><script>window.location.hash = "w04";</script><script src="cljs-out/dev-main.js?v=B7C051F1A748ACCD76D4B4296D0363D00EB480A2"></script><link rel="stylesheet" href="highlightjs/styles/obsidian.css?v=6ED475813FE4886A58B236297862FF2F181E66F7"/><script>slatecljs.common.highlight_source("force");</script><div>You might also like this <a href="https://jeremyrsellars.github.io/no-new-legacy/posts/2018-09-07-generative-testing-introduction/">blog about generative testing in Clojure</a> also by <a href="https://jeremyrsellars.github.io/">Jeremy Sellars</a>.</div></body></html>
